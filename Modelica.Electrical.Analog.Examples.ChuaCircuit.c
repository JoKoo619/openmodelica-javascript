/* Simulation code for Modelica.Electrical.Analog.Examples.ChuaCircuit generated by the OpenModelica Compiler 1.9.0 beta4+dev (r17240). */

#include "openmodelica.h"
#include "openmodelica_func.h"
#include "simulation_data.h"
#include "simulation_info_xml.h"
#include "simulation_runtime.h"
#include "omc_error.h"
#include "model_help.h"

#include <assert.h>
#include <string.h>

#include "Modelica.Electrical.Analog.Examples.ChuaCircuit_functions.h"

#include "Modelica.Electrical.Analog.Examples.ChuaCircuit_model.h"
#include "Modelica.Electrical.Analog.Examples.ChuaCircuit_functions.c"
/* dummy VARINFO and FILEINFO */
const FILE_INFO dummyFILE_INFO = omc_dummyFileInfo;
const VAR_INFO dummyVAR_INFO = omc_dummyVarInfo;
#ifdef __cplusplus
extern "C" {
#endif
#ifdef _OMC_MEASURE_TIME
int measure_time_flag = 1;
#else
int measure_time_flag = 0;
#endif


#ifdef HPCOM
 #include <omp.h>
#endif

#ifdef _OPENMP
 #ifndef HPCOM
  #include <omp.h>
  #include <omp_perform_simulation.c>
 #else
  #include <perform_simulation.c>
 #endif
#else
 #ifndef HPCOM
  #include <perform_simulation.c>
  /* dummy omp defines */
  #define omp_get_max_threads() 1
  #define omp_set_dynamic(X) /* NO omp_set_dynamic */
  #define omp_init_lock(X)   /* NO omp_init_lock */
  #define omp_set_lock(X)    /* NO omp_set_lock */
  #define omp_unset_lock(X)  /* NO omp_unset_lock */
  #define omp_lock_t int
 #else
  #include <perform_simulation.c>
 #endif
#endif


void setupDataStruc(DATA *data)
{
  ASSERT(data, "Error while initialize Data");
  data->modelData.modelName = "Modelica.Electrical.Analog.Examples.ChuaCircuit";
  data->modelData.modelFilePrefix = "Modelica.Electrical.Analog.Examples.ChuaCircuit";
  data->modelData.modelDir = "/usr/lib/omlibrary/Modelica 3.2.1/Electrical/Analog/Examples";
  data->modelData.modelGUID = "{8c4e810f-3df3-4a00-8276-176fa3c9f9e0}";
  #ifdef OPENMODELICA_XML_FROM_FILE_AT_RUNTIME
  data->modelData.initXMLData = NULL;
  data->modelData.modelDataXml.infoXMLData = NULL;
  #else
  #include "Modelica.Electrical.Analog.Examples.ChuaCircuit_init.c"
  #include "Modelica.Electrical.Analog.Examples.ChuaCircuit_info.c"
  #endif
  
  data->modelData.nStates = 3;
  data->modelData.nVariablesReal = 2*3+13;
  data->modelData.nDiscreteReal = 0;
  data->modelData.nVariablesInteger = 0;
  data->modelData.nVariablesBoolean = 0;
  data->modelData.nVariablesString = 0;
  data->modelData.nParametersReal = 14;
  data->modelData.nParametersInteger = 0;
  data->modelData.nParametersBoolean = 2;
  data->modelData.nParametersString = 0;
  data->modelData.nInputVars = 0;
  data->modelData.nOutputVars = 0;
  data->modelData.nJacobians = 5;
  
  data->modelData.nAliasReal = 28;
  data->modelData.nAliasInteger = 0;
  data->modelData.nAliasBoolean = 0;
  data->modelData.nAliasString = 0;
  
  data->modelData.nZeroCrossings = 2;
  data->modelData.nSamples = 0;
  data->modelData.nRelations = 2;
  data->modelData.nMathEvents = 0;
  data->modelData.nInitEquations = 0;
  data->modelData.nInitAlgorithms = 0;
  data->modelData.nInitResiduals = 0;    /* data->modelData.nInitEquations + data->modelData.nInitAlgorithms */
  data->modelData.nExtObjs = 0;
  data->modelData.modelDataXml.fileName = "Modelica.Electrical.Analog.Examples.ChuaCircuit_info.xml";
  data->modelData.modelDataXml.nFunctions = 0;
  data->modelData.modelDataXml.nProfileBlocks = 0;
  data->modelData.modelDataXml.nEquations = 47;
  data->modelData.nMixedSystems = 0;
  data->modelData.nLinearSystems = 0;
  data->modelData.nNonLinearSystems = 0;
  data->modelData.nStateSets = 0;
  data->modelData.nInlineVars = 0;
  
  data->modelData.nDelayExpressions = 0;
  
}


/* Has to be performed after _init.xml file has been read */
void callExternalObjectConstructors(DATA *data)
{
  state mem_state;
  mem_state = get_memory_state();
  /* data->simulationInfo.extObjs = NULL; */
  INFO(LOG_DEBUG, "call external Object Constructors");
  INFO(LOG_DEBUG, "call external Object Constructors finished");
}

void callExternalObjectDestructors(DATA *data)
{
  if(data->simulationInfo.extObjs)
  {
    free(data->simulationInfo.extObjs);
    data->simulationInfo.extObjs = 0;
  }
}


/* funtion initialize non-linear systems */
void initialNonLinearSystem(NONLINEAR_SYSTEM_DATA* nonLinearSystemData)
{
}

/* initial linear systems */
/* inline linear systems */
/* parameter linear systems */
/* model linear systems */
/* jacobians linear systems */

/* funtion initialize linear systems */
void initialLinearSystem(LINEAR_SYSTEM_DATA* linearSystemData)
{
  /* initial linear systems */
  /* inline linear systems */
  /* parameter linear systems */
  /* model linear systems */
  /* jacobians linear systems */
}

/* funtion initialize state sets */
void initializeStateSets(STATE_SET_DATA* statesetData, DATA *data)
{
}

int input_function(DATA *data)
{
  return 0;
}

int output_function(DATA *data)
{
  return 0;
}

/* Initializes the raw time events of the simulation using the now
   calcualted parameters. */
void function_initSample(DATA *data)
{
  long i=0;

}

int function_storeDelayed(DATA *data)
{
  state mem_state;
  
  mem_state = get_memory_state();
  restore_memory_state(mem_state);
  
  return 0;
}

int updateBoundStartValues(DATA *data)
{

  
  INFO(LOG_INIT, "updating start-values");
  INDENT(LOG_INIT);
  RELEASE(LOG_INIT);
  
  return 0;
}

const char *initialResidualDescription[1] = {"empty"};

int initial_residual(DATA *data, double *initialResiduals)
{
  int i = 0;
  state mem_state;
  
  mem_state = get_memory_state();
  INFO(LOG_RES_INIT, "updating initial residuals");
  INDENT(LOG_RES_INIT);
  RELEASE(LOG_RES_INIT);
  restore_memory_state(mem_state);
  
  return 0;
}

/*
 equation index: 1
 type: SIMPLE_ASSIGN
 G._T = G.T_ref
 */
static void eqFunction_1(DATA *data)
{
  $PG$PT = $PG$PT_ref;
}
/*
 equation index: 2
 type: SIMPLE_ASSIGN
 G._G_actual = DIVISION(G.G, 1.0 + G.alpha * (G.T - G.T_ref), #SHARED_LITERAL_5(String)#)
 */
static void eqFunction_2(DATA *data)
{
  modelica_real tmp0;
  tmp0 = DIVISION($PG$PG, (1.0 + ($PG$Palpha * ($PG$PT - $PG$PT_ref))), _OMC_LIT5);
  $PG$PG_actual = tmp0;
}
/*
 equation index: 3
 type: SIMPLE_ASSIGN
 G._v = C2.v - C1.v
 */
static void eqFunction_3(DATA *data)
{
  $PG$Pv = ($PC2$Pv - $PC1$Pv);
}
/*
 equation index: 4
 type: SIMPLE_ASSIGN
 G._i = G.G_actual * G.v
 */
static void eqFunction_4(DATA *data)
{
  $PG$Pi = ($PG$PG_actual * $PG$Pv);
}
/*
 equation index: 5
 type: SIMPLE_ASSIGN
 G._LossPower = G.v * G.i
 */
static void eqFunction_5(DATA *data)
{
  $PG$PLossPower = ($PG$Pv * $PG$Pi);
}
/*
 equation index: 6
 type: SIMPLE_ASSIGN
 Nr._i = if C1.v < (-Nr.Ve) then Nr.Gb * (C1.v + Nr.Ve) - Nr.Ga * Nr.Ve else if C1.v > Nr.Ve then Nr.Gb * (C1.v - Nr.Ve) + Nr.Ga * Nr.Ve else Nr.Ga * C1.v
 */
static void eqFunction_6(DATA *data)
{
  modelica_boolean tmp1;
  modelica_boolean tmp2;
  modelica_boolean tmp3;
  modelica_real tmp4;
  RELATIONHYSTERESIS(tmp1, $PC1$Pv, (-$PNr$PVe), 0, Less);
  tmp3 = (modelica_boolean)tmp1;
  if(tmp3)
  {
    tmp4 = (($PNr$PGb * ($PC1$Pv + $PNr$PVe)) - ($PNr$PGa * $PNr$PVe));
  }
  else
  {
    RELATIONHYSTERESIS(tmp2, $PC1$Pv, $PNr$PVe, 1, Greater);
    tmp4 = (tmp2?(($PNr$PGb * ($PC1$Pv - $PNr$PVe)) + ($PNr$PGa * $PNr$PVe)):($PNr$PGa * $PC1$Pv));
  }
  $PNr$Pi = tmp4;
}
/*
 equation index: 7
 type: SIMPLE_ASSIGN
 C2._i = (-L.i) - G.i
 */
static void eqFunction_7(DATA *data)
{
  $PC2$Pi = ((-$PL$Pi) - $PG$Pi);
}
/*
 equation index: 8
 type: SIMPLE_ASSIGN
 der(C2._v) = DIVISION(C2.i, C2.C, #SHARED_LITERAL_2(String)#)
 */
static void eqFunction_8(DATA *data)
{
  modelica_real tmp5;
  tmp5 = DIVISION($PC2$Pi, $PC2$PC, _OMC_LIT2);
  $P$DER$PC2$Pv = tmp5;
}
/*
 equation index: 9
 type: SIMPLE_ASSIGN
 C1._i = G.i - Nr.i
 */
static void eqFunction_9(DATA *data)
{
  $PC1$Pi = ($PG$Pi - $PNr$Pi);
}
/*
 equation index: 10
 type: SIMPLE_ASSIGN
 Gnd._p._i = C2.i - (-L.i) - C1.i - Nr.i
 */
static void eqFunction_10(DATA *data)
{
  $PGnd$Pp$Pi = ($PC2$Pi - (((-$PL$Pi) - $PC1$Pi) - $PNr$Pi));
}
/*
 equation index: 11
 type: SIMPLE_ASSIGN
 der(C1._v) = DIVISION(C1.i, C1.C, #SHARED_LITERAL_3(String)#)
 */
static void eqFunction_11(DATA *data)
{
  modelica_real tmp6;
  tmp6 = DIVISION($PC1$Pi, $PC1$PC, _OMC_LIT3);
  $P$DER$PC1$Pv = tmp6;
}
/*
 equation index: 12
 type: SIMPLE_ASSIGN
 Ro._T = Ro.T_ref
 */
static void eqFunction_12(DATA *data)
{
  $PRo$PT = $PRo$PT_ref;
}
/*
 equation index: 13
 type: SIMPLE_ASSIGN
 Ro._R_actual = Ro.R * (1.0 + Ro.alpha * (Ro.T - Ro.T_ref))
 */
static void eqFunction_13(DATA *data)
{
  $PRo$PR_actual = ($PRo$PR * (1.0 + ($PRo$Palpha * ($PRo$PT - $PRo$PT_ref))));
}
/*
 equation index: 14
 type: SIMPLE_ASSIGN
 Ro._v = Ro.R_actual * L.i
 */
static void eqFunction_14(DATA *data)
{
  $PRo$Pv = ($PRo$PR_actual * $PL$Pi);
}
/*
 equation index: 15
 type: SIMPLE_ASSIGN
 L._v = C2.v - Ro.v
 */
static void eqFunction_15(DATA *data)
{
  $PL$Pv = ($PC2$Pv - $PRo$Pv);
}
/*
 equation index: 16
 type: SIMPLE_ASSIGN
 der(L._i) = DIVISION(L.v, L.L, #SHARED_LITERAL_4(String)#)
 */
static void eqFunction_16(DATA *data)
{
  modelica_real tmp7;
  tmp7 = DIVISION($PL$Pv, $PL$PL, _OMC_LIT4);
  $P$DER$PL$Pi = tmp7;
}
/*
 equation index: 17
 type: SIMPLE_ASSIGN
 Ro._LossPower = Ro.v * L.i
 */
static void eqFunction_17(DATA *data)
{
  $PRo$PLossPower = ($PRo$Pv * $PL$Pi);
}
/*
 equation index: 18
 type: SIMPLE_ASSIGN
 Gnd._p._v = 0.0
 */
static void eqFunction_18(DATA *data)
{
  $PGnd$Pp$Pv = 0.0;
}
const int useSymbolicInitialization = 1; /* true */
const int useHomotopy = 0; /* false */
int functionInitialEquations(DATA *data)
{
  state mem_state;
  
  mem_state = get_memory_state();
  data->simulationInfo.discreteCall = 1;
  eqFunction_1(data);
  restore_memory_state(mem_state);
  eqFunction_2(data);
  restore_memory_state(mem_state);
  eqFunction_3(data);
  restore_memory_state(mem_state);
  eqFunction_4(data);
  restore_memory_state(mem_state);
  eqFunction_5(data);
  restore_memory_state(mem_state);
  eqFunction_6(data);
  restore_memory_state(mem_state);
  eqFunction_7(data);
  restore_memory_state(mem_state);
  eqFunction_8(data);
  restore_memory_state(mem_state);
  eqFunction_9(data);
  restore_memory_state(mem_state);
  eqFunction_10(data);
  restore_memory_state(mem_state);
  eqFunction_11(data);
  restore_memory_state(mem_state);
  eqFunction_12(data);
  restore_memory_state(mem_state);
  eqFunction_13(data);
  restore_memory_state(mem_state);
  eqFunction_14(data);
  restore_memory_state(mem_state);
  eqFunction_15(data);
  restore_memory_state(mem_state);
  eqFunction_16(data);
  restore_memory_state(mem_state);
  eqFunction_17(data);
  restore_memory_state(mem_state);
  eqFunction_18(data);
  restore_memory_state(mem_state);
  data->simulationInfo.discreteCall = 0;
  
  return 0;
}

int functionInlineEquations(DATA *data)
{
  state mem_state;
  
  mem_state = get_memory_state();
  restore_memory_state(mem_state);
  
  return 0;
}


/*
 equation index: 32
 type: SIMPLE_ASSIGN
 Gnd._p._v = 0.0
 */
static void eqFunction_32(DATA *data)
{
  $PGnd$Pp$Pv = 0.0;
}
/*
 equation index: 33
 type: SIMPLE_ASSIGN
 Ro._T = Ro.T_ref
 */
static void eqFunction_33(DATA *data)
{
  $PRo$PT = $PRo$PT_ref;
}
/*
 equation index: 34
 type: SIMPLE_ASSIGN
 Ro._R_actual = Ro.R * (1.0 + Ro.alpha * (Ro.T - Ro.T_ref))
 */
static void eqFunction_34(DATA *data)
{
  $PRo$PR_actual = ($PRo$PR * (1.0 + ($PRo$Palpha * ($PRo$PT - $PRo$PT_ref))));
}
/*
 equation index: 35
 type: SIMPLE_ASSIGN
 G._T = G.T_ref
 */
static void eqFunction_35(DATA *data)
{
  $PG$PT = $PG$PT_ref;
}
/*
 equation index: 36
 type: SIMPLE_ASSIGN
 G._G_actual = DIVISION(G.G, 1.0 + G.alpha * (G.T - G.T_ref), #SHARED_LITERAL_5(String)#)
 */
static void eqFunction_36(DATA *data)
{
  modelica_real tmp0;
  tmp0 = DIVISION($PG$PG, (1.0 + ($PG$Palpha * ($PG$PT - $PG$PT_ref))), _OMC_LIT5);
  $PG$PG_actual = tmp0;
}
/*
 equation index: 37
 type: ALGORITHM
 
   assert(Nr.Gb >= -1.0, "Variable Nr.Gb out of [min, max] interval: Nr.Gb >= -1.0 has value: " + String(Nr.Gb, "g"));
 */
static void eqFunction_37(DATA *data)
{
  modelica_boolean tmp1;
  modelica_string tmp2;
  modelica_string tmp3;
  static int tmp4 = 0;
  if(!tmp4)
  {
    tmp1 = GreaterEq($PNr$PGb,-1.0);
    if(!tmp1)
    {
      tmp2 = modelica_real_to_modelica_string_format($PNr$PGb, "g");
      tmp3 = cat_modelica_string("Variable Nr.Gb out of [min, max] interval: Nr.Gb >= -1.0 has value: ",tmp2);
      FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.1/Electrical/Analog/Examples/Utilities/NonlinearResistor.mo",6,3,6,67,1};
      omc_assert_warning(info, tmp3);
      tmp4 = 1;
    }
  }
}
/*
 equation index: 38
 type: ALGORITHM
 
   assert(Nr.Ga >= -1.0, "Variable Nr.Ga out of [min, max] interval: Nr.Ga >= -1.0 has value: " + String(Nr.Ga, "g"));
 */
static void eqFunction_38(DATA *data)
{
  modelica_boolean tmp5;
  modelica_string tmp6;
  modelica_string tmp7;
  static int tmp8 = 0;
  if(!tmp8)
  {
    tmp5 = GreaterEq($PNr$PGa,-1.0);
    if(!tmp5)
    {
      tmp6 = modelica_real_to_modelica_string_format($PNr$PGa, "g");
      tmp7 = cat_modelica_string("Variable Nr.Ga out of [min, max] interval: Nr.Ga >= -1.0 has value: ",tmp6);
      FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.1/Electrical/Analog/Examples/Utilities/NonlinearResistor.mo",5,3,5,67,1};
      omc_assert_warning(info, tmp7);
      tmp8 = 1;
    }
  }
}
/*
 equation index: 39
 type: ALGORITHM
 
   assert(C2.C >= 0.0, "Variable C2.C out of [min, max] interval: C2.C >= 0.0 has value: " + String(C2.C, "g"));
 */
static void eqFunction_39(DATA *data)
{
  modelica_boolean tmp9;
  modelica_string tmp10;
  modelica_string tmp11;
  static int tmp12 = 0;
  if(!tmp12)
  {
    tmp9 = GreaterEq($PC2$PC,0.0);
    if(!tmp9)
    {
      tmp10 = modelica_real_to_modelica_string_format($PC2$PC, "g");
      tmp11 = cat_modelica_string("Variable C2.C out of [min, max] interval: C2.C >= 0.0 has value: ",tmp10);
      FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.1/Electrical/Analog/Basic.mo",283,5,283,54,1};
      omc_assert_warning(info, tmp11);
      tmp12 = 1;
    }
  }
}
/*
 equation index: 40
 type: ALGORITHM
 
   assert(C1.C >= 0.0, "Variable C1.C out of [min, max] interval: C1.C >= 0.0 has value: " + String(C1.C, "g"));
 */
static void eqFunction_40(DATA *data)
{
  modelica_boolean tmp13;
  modelica_string tmp14;
  modelica_string tmp15;
  static int tmp16 = 0;
  if(!tmp16)
  {
    tmp13 = GreaterEq($PC1$PC,0.0);
    if(!tmp13)
    {
      tmp14 = modelica_real_to_modelica_string_format($PC1$PC, "g");
      tmp15 = cat_modelica_string("Variable C1.C out of [min, max] interval: C1.C >= 0.0 has value: ",tmp14);
      FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.1/Electrical/Analog/Basic.mo",283,5,283,54,1};
      omc_assert_warning(info, tmp15);
      tmp16 = 1;
    }
  }
}
/*
 equation index: 41
 type: ALGORITHM
 
   assert(G.T_ref >= 0.0, "Variable G.T_ref out of [min, max] interval: G.T_ref >= 0.0 has value: " + String(G.T_ref, "g"));
 */
static void eqFunction_41(DATA *data)
{
  modelica_boolean tmp17;
  modelica_string tmp18;
  modelica_string tmp19;
  static int tmp20 = 0;
  if(!tmp20)
  {
    tmp17 = GreaterEq($PG$PT_ref,0.0);
    if(!tmp17)
    {
      tmp18 = modelica_real_to_modelica_string_format($PG$PT_ref, "g");
      tmp19 = cat_modelica_string("Variable G.T_ref out of [min, max] interval: G.T_ref >= 0.0 has value: ",tmp18);
      FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.1/Electrical/Analog/Basic.mo",217,3,217,78,1};
      omc_assert_warning(info, tmp19);
      tmp20 = 1;
    }
  }
}
/*
 equation index: 42
 type: ALGORITHM
 
   assert(G.T >= 0.0, "Variable G.T out of [min, max] interval: G.T >= 0.0 has value: " + String(G.T, "g"));
 */
static void eqFunction_42(DATA *data)
{
  modelica_boolean tmp21;
  modelica_string tmp22;
  modelica_string tmp23;
  static int tmp24 = 0;
  if(!tmp24)
  {
    tmp21 = GreaterEq($PG$PT,0.0);
    if(!tmp21)
    {
      tmp22 = modelica_real_to_modelica_string_format($PG$PT, "g");
      tmp23 = cat_modelica_string("Variable G.T out of [min, max] interval: G.T >= 0.0 has value: ",tmp22);
      FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.1/Electrical/Analog/Interfaces.mo",306,5,307,99,1};
      omc_assert_warning(info, tmp23);
      tmp24 = 1;
    }
  }
}
/*
 equation index: 43
 type: ALGORITHM
 
   assert(Ro.T_ref >= 0.0, "Variable Ro.T_ref out of [min, max] interval: Ro.T_ref >= 0.0 has value: " + String(Ro.T_ref, "g"));
 */
static void eqFunction_43(DATA *data)
{
  modelica_boolean tmp25;
  modelica_string tmp26;
  modelica_string tmp27;
  static int tmp28 = 0;
  if(!tmp28)
  {
    tmp25 = GreaterEq($PRo$PT_ref,0.0);
    if(!tmp25)
    {
      tmp26 = modelica_real_to_modelica_string_format($PRo$PT_ref, "g");
      tmp27 = cat_modelica_string("Variable Ro.T_ref out of [min, max] interval: Ro.T_ref >= 0.0 has value: ",tmp26);
      FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.1/Electrical/Analog/Basic.mo",64,3,64,78,1};
      omc_assert_warning(info, tmp27);
      tmp28 = 1;
    }
  }
}
/*
 equation index: 44
 type: ALGORITHM
 
   assert(Ro.T >= 0.0, "Variable Ro.T out of [min, max] interval: Ro.T >= 0.0 has value: " + String(Ro.T, "g"));
 */
static void eqFunction_44(DATA *data)
{
  modelica_boolean tmp29;
  modelica_string tmp30;
  modelica_string tmp31;
  static int tmp32 = 0;
  if(!tmp32)
  {
    tmp29 = GreaterEq($PRo$PT,0.0);
    if(!tmp29)
    {
      tmp30 = modelica_real_to_modelica_string_format($PRo$PT, "g");
      tmp31 = cat_modelica_string("Variable Ro.T out of [min, max] interval: Ro.T >= 0.0 has value: ",tmp30);
      FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.1/Electrical/Analog/Interfaces.mo",306,5,307,99,1};
      omc_assert_warning(info, tmp31);
      tmp32 = 1;
    }
  }
}
int updateBoundParameters(DATA *data)
{
  state mem_state;
  mem_state = get_memory_state();
  eqFunction_32(data);
  restore_memory_state(mem_state);
  eqFunction_33(data);
  restore_memory_state(mem_state);
  eqFunction_34(data);
  restore_memory_state(mem_state);
  eqFunction_35(data);
  restore_memory_state(mem_state);
  eqFunction_36(data);
  restore_memory_state(mem_state);
  eqFunction_37(data);
  restore_memory_state(mem_state);
  eqFunction_38(data);
  restore_memory_state(mem_state);
  eqFunction_39(data);
  restore_memory_state(mem_state);
  eqFunction_40(data);
  restore_memory_state(mem_state);
  eqFunction_41(data);
  restore_memory_state(mem_state);
  eqFunction_42(data);
  restore_memory_state(mem_state);
  eqFunction_43(data);
  restore_memory_state(mem_state);
  eqFunction_44(data);
  restore_memory_state(mem_state);
  
  return 0;
}


/*
 equation index: 19
 type: SIMPLE_ASSIGN
 Nr._i = if C1.v < (-Nr.Ve) then Nr.Gb * (C1.v + Nr.Ve) - Nr.Ga * Nr.Ve else if C1.v > Nr.Ve then Nr.Gb * (C1.v - Nr.Ve) + Nr.Ga * Nr.Ve else Nr.Ga * C1.v
 */
static void eqFunction_19(DATA *data)
{
  modelica_boolean tmp33;
  modelica_boolean tmp34;
  modelica_boolean tmp35;
  modelica_real tmp36;
  RELATIONHYSTERESIS(tmp33, $PC1$Pv, (-$PNr$PVe), 0, Less);
  tmp35 = (modelica_boolean)tmp33;
  if(tmp35)
  {
    tmp36 = (($PNr$PGb * ($PC1$Pv + $PNr$PVe)) - ($PNr$PGa * $PNr$PVe));
  }
  else
  {
    RELATIONHYSTERESIS(tmp34, $PC1$Pv, $PNr$PVe, 1, Greater);
    tmp36 = (tmp34?(($PNr$PGb * ($PC1$Pv - $PNr$PVe)) + ($PNr$PGa * $PNr$PVe)):($PNr$PGa * $PC1$Pv));
  }
  $PNr$Pi = tmp36;
}
/*
 equation index: 20
 type: SIMPLE_ASSIGN
 G._v = C2.v - C1.v
 */
static void eqFunction_20(DATA *data)
{
  $PG$Pv = ($PC2$Pv - $PC1$Pv);
}
/*
 equation index: 21
 type: SIMPLE_ASSIGN
 G._i = G.G_actual * G.v
 */
static void eqFunction_21(DATA *data)
{
  $PG$Pi = ($PG$PG_actual * $PG$Pv);
}
/*
 equation index: 22
 type: SIMPLE_ASSIGN
 G._LossPower = G.v * G.i
 */
static void eqFunction_22(DATA *data)
{
  $PG$PLossPower = ($PG$Pv * $PG$Pi);
}
/*
 equation index: 23
 type: SIMPLE_ASSIGN
 C2._i = (-L.i) - G.i
 */
static void eqFunction_23(DATA *data)
{
  $PC2$Pi = ((-$PL$Pi) - $PG$Pi);
}
/*
 equation index: 24
 type: SIMPLE_ASSIGN
 der(C2._v) = DIVISION(C2.i, C2.C, #SHARED_LITERAL_2(String)#)
 */
static void eqFunction_24(DATA *data)
{
  modelica_real tmp37;
  tmp37 = DIVISION($PC2$Pi, $PC2$PC, _OMC_LIT2);
  $P$DER$PC2$Pv = tmp37;
}
/*
 equation index: 25
 type: SIMPLE_ASSIGN
 C1._i = G.i - Nr.i
 */
static void eqFunction_25(DATA *data)
{
  $PC1$Pi = ($PG$Pi - $PNr$Pi);
}
/*
 equation index: 26
 type: SIMPLE_ASSIGN
 der(C1._v) = DIVISION(C1.i, C1.C, #SHARED_LITERAL_3(String)#)
 */
static void eqFunction_26(DATA *data)
{
  modelica_real tmp38;
  tmp38 = DIVISION($PC1$Pi, $PC1$PC, _OMC_LIT3);
  $P$DER$PC1$Pv = tmp38;
}
/*
 equation index: 27
 type: SIMPLE_ASSIGN
 Gnd._p._i = C2.i - (-L.i) - C1.i - Nr.i
 */
static void eqFunction_27(DATA *data)
{
  $PGnd$Pp$Pi = ($PC2$Pi - (((-$PL$Pi) - $PC1$Pi) - $PNr$Pi));
}
/*
 equation index: 28
 type: SIMPLE_ASSIGN
 Ro._v = Ro.R_actual * L.i
 */
static void eqFunction_28(DATA *data)
{
  $PRo$Pv = ($PRo$PR_actual * $PL$Pi);
}
/*
 equation index: 29
 type: SIMPLE_ASSIGN
 Ro._LossPower = Ro.v * L.i
 */
static void eqFunction_29(DATA *data)
{
  $PRo$PLossPower = ($PRo$Pv * $PL$Pi);
}
/*
 equation index: 30
 type: SIMPLE_ASSIGN
 L._v = C2.v - Ro.v
 */
static void eqFunction_30(DATA *data)
{
  $PL$Pv = ($PC2$Pv - $PRo$Pv);
}
/*
 equation index: 31
 type: SIMPLE_ASSIGN
 der(L._i) = DIVISION(L.v, L.L, #SHARED_LITERAL_4(String)#)
 */
static void eqFunction_31(DATA *data)
{
  modelica_real tmp39;
  tmp39 = DIVISION($PL$Pv, $PL$PL, _OMC_LIT4);
  $P$DER$PL$Pi = tmp39;
}
/*
 equation index: 46
 type: ALGORITHM
 
   assert(1.0 + Ro.alpha * (Ro.T - Ro.T_ref) >= 0.000000000000001, "Temperature outside scope of model!");
 */
static void eqFunction_46(DATA *data)
{
  modelica_boolean tmp40;
  tmp40 = GreaterEq((1.0 + ($PRo$Palpha * ($PRo$PT - $PRo$PT_ref))),0.000000000000001);
  if(!tmp40)
  {
      FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.1/Electrical/Analog/Basic.mo",74,3,74,108,1};
      omc_assert(info, "Temperature outside scope of model!");
  }
}
/*
 equation index: 45
 type: ALGORITHM
 
   assert(1.0 + G.alpha * (G.T - G.T_ref) >= 0.000000000000001, "Temperature outside scope of model!");
 */
static void eqFunction_45(DATA *data)
{
  modelica_boolean tmp41;
  tmp41 = GreaterEq((1.0 + ($PG$Palpha * ($PG$PT - $PG$PT_ref))),0.000000000000001);
  if(!tmp41)
  {
      FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.1/Electrical/Analog/Basic.mo",227,3,227,108,1};
      omc_assert(info, "Temperature outside scope of model!");
  }
}
int functionDAE(DATA *data)
{
  state mem_state;
  data->simulationInfo.needToIterate = 0;
  data->simulationInfo.discreteCall = 1;
  mem_state = get_memory_state();
  eqFunction_19(data);
  eqFunction_20(data);
  eqFunction_21(data);
  eqFunction_22(data);
  eqFunction_23(data);
  eqFunction_24(data);
  eqFunction_25(data);
  eqFunction_26(data);
  eqFunction_27(data);
  eqFunction_28(data);
  eqFunction_29(data);
  eqFunction_30(data);
  eqFunction_31(data);
  eqFunction_46(data);
  eqFunction_45(data);
  restore_memory_state(mem_state);
  
  return 0;
}

static void functionODE_system0(DATA *data)
{
  state mem_state;
  mem_state = get_memory_state();
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_TICK_EQEXT(19);
  #endif
  eqFunction_19(data);
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_ACC_EQEXT(19);
  #endif
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_TICK_EQEXT(20);
  #endif
  eqFunction_20(data);
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_ACC_EQEXT(20);
  #endif
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_TICK_EQEXT(21);
  #endif
  eqFunction_21(data);
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_ACC_EQEXT(21);
  #endif
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_TICK_EQEXT(23);
  #endif
  eqFunction_23(data);
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_ACC_EQEXT(23);
  #endif
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_TICK_EQEXT(24);
  #endif
  eqFunction_24(data);
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_ACC_EQEXT(24);
  #endif
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_TICK_EQEXT(25);
  #endif
  eqFunction_25(data);
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_ACC_EQEXT(25);
  #endif
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_TICK_EQEXT(26);
  #endif
  eqFunction_26(data);
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_ACC_EQEXT(26);
  #endif
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_TICK_EQEXT(28);
  #endif
  eqFunction_28(data);
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_ACC_EQEXT(28);
  #endif
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_TICK_EQEXT(30);
  #endif
  eqFunction_30(data);
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_ACC_EQEXT(30);
  #endif
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_TICK_EQEXT(31);
  #endif
  eqFunction_31(data);
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_ACC_EQEXT(31);
  #endif
  restore_memory_state(mem_state);
}

void function_initMemoryState()
{
#ifdef _OPENMP
  push_memory_states(omp_get_max_threads());
  get_thread_index = omp_get_thread_num;
#else
  push_memory_states(1);
#endif
}

int functionODE(DATA *data)
{
#ifdef _OMC_MEASURE_TIME
  rt_tick(SIM_TIMER_FUNCTION_ODE);
#endif

  state mem_state; /* We need to have separate memory pools for separate systems... */
  mem_state = get_memory_state();
  
  data->simulationInfo.discreteCall = 0;
  functionODE_system0(data);
  restore_memory_state(mem_state);
#ifdef _OMC_MEASURE_TIME
  rt_accumulate(SIM_TIMER_FUNCTION_ODE);
#endif

  return 0;
}

#include <simulation_inline_solver.h>
const char *_omc_force_solver=_OMC_FORCE_SOLVER;
const int inline_work_states_ndims=_OMC_SOLVER_WORK_STATES_NDIMS;
int functionODE_inline(DATA* data, double stepSize)
{
  return 0;
}

static void functionAlg_system0(DATA *data)
{
  state mem_state;
  mem_state = get_memory_state();
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_TICK_EQEXT(22);
  #endif
  eqFunction_22(data);
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_ACC_EQEXT(22);
  #endif
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_TICK_EQEXT(27);
  #endif
  eqFunction_27(data);
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_ACC_EQEXT(27);
  #endif
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_TICK_EQEXT(29);
  #endif
  eqFunction_29(data);
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_ACC_EQEXT(29);
  #endif
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_TICK_EQEXT(46);
  #endif
  eqFunction_46(data);
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_ACC_EQEXT(46);
  #endif
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_TICK_EQEXT(45);
  #endif
  eqFunction_45(data);
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_ACC_EQEXT(45);
  #endif
  restore_memory_state(mem_state);
}
/* for continuous time variables */
int functionAlgebraics(DATA *data)
{
  data->simulationInfo.discreteCall = 0;
  functionAlg_system0(data);
  return 0;
}

const char *zeroCrossingDescription[] =
{
  "C1.v < (-Nr.Ve)", 
  "C1.v > Nr.Ve", 
};

int function_ZeroCrossings(DATA *data, double *gout, double *t)
{
  state mem_state;
  modelica_boolean tmp3;
  modelica_boolean tmp4;
  
  mem_state = get_memory_state();
  tmp3 = LessZC($PC1$Pv,(-$PNr$PVe), data->simulationInfo.hysteresisEnabled[0]);
  ZEROCROSSING(0, (tmp3)?1:-1);
  tmp4 = GreaterZC($PC1$Pv,$PNr$PVe, data->simulationInfo.hysteresisEnabled[1]);
  ZEROCROSSING(1, (tmp4)?1:-1);
  restore_memory_state(mem_state);
  
  return 0;
}

const char *relationDescription[] =
{
  "C1.v < (-Nr.Ve)", 
  "C1.v > Nr.Ve", 
};

int function_updateRelations(DATA *data, int evalforZeroCross)
{
  state mem_state;
  modelica_boolean tmp5;
  modelica_boolean tmp6;
  
  mem_state = get_memory_state();
  if(evalforZeroCross)
  {
    tmp5 = LessZC($PC1$Pv,(-$PNr$PVe), data->simulationInfo.hysteresisEnabled[0]);
    data->simulationInfo.relations[0] = tmp5;
    tmp6 = GreaterZC($PC1$Pv,$PNr$PVe, data->simulationInfo.hysteresisEnabled[1]);
    data->simulationInfo.relations[1] = tmp6;
  }
  else
  {
    data->simulationInfo.relations[0] = ($PC1$Pv < (-$PNr$PVe));
    data->simulationInfo.relations[1] = ($PC1$Pv > $PNr$PVe);
  }
  restore_memory_state(mem_state);
  
  return 0;
}

int checkForDiscreteChanges(DATA *data)
{
  int needToIterate = 0;

  DEBUG(LOG_EVENTS, "check for discrete changes");
  INDENT(LOG_EVENTS);
  RELEASE(LOG_EVENTS);
  
  return needToIterate;
}

/* function to check assert after a step is done */
int checkForAsserts(DATA *data)
{

  
  return 0;
}

/* initial mixed systems */
/* inline mixed systems */
/* parameter mixed systems */
/* model mixed systems */
/* jacobians mixed systems */

/* funtion initialize mixed systems */
void initialMixedSystem(MIXED_SYSTEM_DATA* mixedSystemData)
{
  /* initial mixed systems */
  /* inline mixed systems */
  /* parameter mixed systems */
  /* model mixed systems */
  /* jacobians mixed systems */
}

int initialAnalyticJacobianG(void* inData)
{
  return 1;
}
int initialAnalyticJacobianA(void* inData)
{
  DATA* data = ((DATA*)inData);
  int index = INDEX_JAC_A;
  
  int i;
  
  data->simulationInfo.analyticJacobians[index].sizeCols = 3;
  data->simulationInfo.analyticJacobians[index].sizeRows = 3;
  data->simulationInfo.analyticJacobians[index].seedVars = (modelica_real*) calloc(3,sizeof(modelica_real));
  data->simulationInfo.analyticJacobians[index].resultVars = (modelica_real*) malloc(3*sizeof(modelica_real));
  data->simulationInfo.analyticJacobians[index].tmpVars = (modelica_real*) malloc(0*sizeof(modelica_real));
  data->simulationInfo.analyticJacobians[index].sparsePattern.leadindex = (unsigned int*) malloc(3*sizeof(int));
  data->simulationInfo.analyticJacobians[index].sparsePattern.index = (unsigned int*) malloc(7*sizeof(int));
  data->simulationInfo.analyticJacobians[index].sparsePattern.colorCols = (unsigned int*) malloc(3*sizeof(int));
  data->simulationInfo.analyticJacobians[index].sparsePattern.maxColors = 3;
  data->simulationInfo.analyticJacobians[index].jacobian = NULL;
  
  /* write column ptr of compressed sparse column*/
  data->simulationInfo.analyticJacobians[index].sparsePattern.leadindex[$PL$Pi$pDERA$indexdiff] = 2;
  data->simulationInfo.analyticJacobians[index].sparsePattern.leadindex[$PC1$Pv$pDERA$indexdiff] = 2;
  data->simulationInfo.analyticJacobians[index].sparsePattern.leadindex[$PC2$Pv$pDERA$indexdiff] = 3;
  for(i=1;i<3;++i)
      data->simulationInfo.analyticJacobians[index].sparsePattern.leadindex[i] += data->simulationInfo.analyticJacobians[index].sparsePattern.leadindex[i-1];
  
  
  /* write index */
  i = data->simulationInfo.analyticJacobians[index].sparsePattern.leadindex[$PL$Pi$pDERA$indexdiff] - 2;
  data->simulationInfo.analyticJacobians[index].sparsePattern.index[i+0] = $PC2$Pv$pDERA$indexdiffed;
  i = data->simulationInfo.analyticJacobians[index].sparsePattern.leadindex[$PL$Pi$pDERA$indexdiff] - 2;
  data->simulationInfo.analyticJacobians[index].sparsePattern.index[i+1] = $PL$Pi$pDERA$indexdiffed;
  i = data->simulationInfo.analyticJacobians[index].sparsePattern.leadindex[$PC1$Pv$pDERA$indexdiff] - 2;
  data->simulationInfo.analyticJacobians[index].sparsePattern.index[i+0] = $PC2$Pv$pDERA$indexdiffed;
  i = data->simulationInfo.analyticJacobians[index].sparsePattern.leadindex[$PC1$Pv$pDERA$indexdiff] - 2;
  data->simulationInfo.analyticJacobians[index].sparsePattern.index[i+1] = $PC1$Pv$pDERA$indexdiffed;
  i = data->simulationInfo.analyticJacobians[index].sparsePattern.leadindex[$PC2$Pv$pDERA$indexdiff] - 3;
  data->simulationInfo.analyticJacobians[index].sparsePattern.index[i+0] = $PC2$Pv$pDERA$indexdiffed;
  i = data->simulationInfo.analyticJacobians[index].sparsePattern.leadindex[$PC2$Pv$pDERA$indexdiff] - 3;
  data->simulationInfo.analyticJacobians[index].sparsePattern.index[i+1] = $PC1$Pv$pDERA$indexdiffed;
  i = data->simulationInfo.analyticJacobians[index].sparsePattern.leadindex[$PC2$Pv$pDERA$indexdiff] - 3;
  data->simulationInfo.analyticJacobians[index].sparsePattern.index[i+2] = $PL$Pi$pDERA$indexdiffed;
  
  /* write color array */
  data->simulationInfo.analyticJacobians[index].sparsePattern.colorCols[$PL$Pi$pDERA$indexdiff] = 1;
  data->simulationInfo.analyticJacobians[index].sparsePattern.colorCols[$PC1$Pv$pDERA$indexdiff] = 2;
  data->simulationInfo.analyticJacobians[index].sparsePattern.colorCols[$PC2$Pv$pDERA$indexdiff] = 3;
  
  return 0;
}
int initialAnalyticJacobianB(void* inData)
{
  return 1;
}
int initialAnalyticJacobianC(void* inData)
{
  return 1;
}
int initialAnalyticJacobianD(void* inData)
{
  return 1;
}

int functionJacG_column(void* data)
{
  return 0;
}
int functionJacA_column(void* inData)
{
  state mem_state;
  DATA* data = ((DATA*)inData);
  int index = INDEX_JAC_A;
  mem_state = get_memory_state();
  restore_memory_state(mem_state);
  return 0;
}
int functionJacB_column(void* data)
{
  return 0;
}
int functionJacC_column(void* data)
{
  return 0;
}
int functionJacD_column(void* data)
{
  return 0;
}
int mayer(DATA* data, modelica_real* res){return -1;}
     int lagrange(DATA* data, modelica_real* res){return -1;}
const char *linear_model_frame =
  "model linear_Modelica_Electrical_Analog_Examples_ChuaCircuit\n  parameter Integer n = 3; // states \n  parameter Integer k = 0; // top-level inputs \n  parameter Integer l = 0; // top-level outputs \n"
  "  parameter Real x0[3] = {%s};\n"
  "  parameter Real u0[0] = {%s};\n"
  "  parameter Real A[3,3] = [%s];\n"
  "  parameter Real B[3,0] = zeros(3,0);%s\n"
  "  parameter Real C[0,3] = zeros(0,3);%s\n"
  "  parameter Real D[0,0] = zeros(0,0);%s\n"
  "  Real x[3](start=x0);\n"
  "  input Real u[0];\n"
  "  output Real y[0];\n"
  "\n  Real x_PC2Pv = x[1];\n  Real x_PC1Pv = x[2];\n  Real x_PLPi = x[3];\n      \n"
  "equation\n  der(x) = A * x + B * u;\n  y = C * x + D * u;\nend linear_Modelica_Electrical_Analog_Examples_ChuaCircuit;\n"
;

extern int _main_SimulationRuntime(int argc, char**argv, DATA *data);

/* call the simulation runtime main from our main! */
int main(int argc, char**argv)
{
  DATA data;
  setupDataStruc(&data);
  return _main_SimulationRuntime(argc, argv, &data);
}
#ifdef __cplusplus
}
#endif


